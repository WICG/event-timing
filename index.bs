<pre class=metadata>
Title: Event Timing API
Status: CG-DRAFT
Shortname: event-timing
Group: WICG
Level: 1
Editor: Nicolás Peña Moreno, Google https://google.com, npm@chromium.org
        Tim Dresser, Google https://google.com, tdresser@chromium.org
URL: https://wicg.github.io/event-timing
Repository: https://github.com/WICG/event-timing
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/event-timing
Abstract: This document defines an API that provides web page authors with insights into the latency of certain events triggered by user interactions.
Default Highlight: js
Complain About: accidental-2119 yes
</pre>

<pre class=anchors>
urlPrefix: https://w3c.github.io/performance-timeline/; spec: PERFORMANCE-TIMELINE-2;
    type: interface; url: #the-performanceentry-interface; text: PerformanceEntry;
    type: attribute; for: PerformanceEntry;
        text: name; url: #dom-performanceentry-name;
        text: entryType; url: #dom-performanceentry-entrytype;
        text: startTime; url: #dom-performanceentry-starttime;
        text: duration; url: #dom-performanceentry-duration;
    type: dfn; url: #dfn-register-a-performance-entry-type; text: register a performance entry type;
    type: dfn; url: #dfn-queue-a-performanceentry; text: queue the entry;
urlPrefix: https://w3c.github.io/hr-time/; spec: HR-TIME-2;
    type: typedef; url: #idl-def-domhighrestimestamp; text: DOMHighResTimeStamp;
    type: interface; url: #dfn-performance; text: Performance;
    type: dfn; url: #dom-performance-now; text: performance.now();
    type: dfn; text: current high resolution time; url: #dfn-current-high-resolution-time;
    type: attribute; for: WindowOrWorkerGlobalScope;
        text: performance; url: #dom-windoworworkerglobalscope-performance;
urlPrefix: https://tc39.github.io/ecma262/; spec: ECMASCRIPT;
    type: dfn; url: #sec-math.round; text: Math.round;
urlPrefix: https://dom.spec.whatwg.org/; spec: DOM;
    type: attribute; for: Event;
        text: type; url: #dom-event-type;
        text: timeStamp; url: #dom-event-timestamp;
        text: cancelable; url: #dom-event-cancelable;
        text: isTrusted; url: #dom-event-istrusted;
    type: dfn; url: #concept-event-dispatch; text: event dispatch algorithm
urlPrefix: https://w3c.github.io/pointerevents/; spec: POINTEREVENTS;
    type: interface; url: #pointerevent-interface; text: PointerEvent;
    type: dfn; url: #the-pointerover-event; text: pointerover;
    type: dfn; url: #the-pointerenter-event; text: pointerenter;
    type: dfn; url: #the-pointerdown-event; text: pointerdown;
    type: dfn; url: #the-pointermove-event; text: pointermove;
    type: dfn; url: #the-pointerup-event; text: pointerup;
    type: dfn; url: #the-pointercancel-event; text: pointercancel;
    type: dfn; url: #the-pointerout-event; text: pointerout;
    type: dfn; url: #the-pointerleave-event; text: pointerleave;
    type: dfn; url: #the-gotpointercapture-event; text: gotpointercapture;
    type: dfn; url: #the-lostpointercapture-event; text: lostpointercapture;
<!-- TODO there does not seem to be a way to link to getCoalescedEvents properly -->
urlPrefix: https://w3c.github.io/pointerevents/extension.html; spec: POINTEREVENTS-EXTENSION;
    type: method; for: PointerEvent;
        url: #dom-pointerevent-getcoalescedevents; text: getCoalescedEvents();
urlPrefix: https://w3c.github.io/touch-events/; spec: TOUCH-EVENTS;
    type: interface; url: #touchevent-interface; text: TouchEvent;
    type: dfn; url: #the-touchstart-event; text: touchstart;
    type: dfn; url: #the-touchend-event; text: touchend;
    type: dfn; url: #the-touchmove-event; text: touchmove;
    type: dfn; url: #the-touchcancel-event; text: touchcancel;
urlPrefix: https://w3c.github.io/paint-timing/; spec: PAINT-TIMING;
    type: dfn; url: #mark-paint-timing; text: mark paint timing;
urlPrefix: https://w3c.github.io/uievents/; spec: UIEVENTS;
    type: dfn; url: #event-type-auxclick; text: auxclick;
    type: dfn; url: #event-type-click; text: click;
    type: dfn; url: #event-type-dblclick; text: dblclick;
    type: dfn; url: #event-type-mousedown; text: mousedown;
    type: dfn; url: #event-type-mouseenter; text: mouseenter;
    type: dfn; url: #event-type-mouseleave; text: mouseleave;
    type: dfn; url: #event-type-mousemove; text: mousemove;
    type: dfn; url: #event-type-mouseout; text: mouseout;
    type: dfn; url: #event-type-mouseover; text: mouseover;
    type: dfn; url: #event-type-mouseup; text: mouseup;
    type: dfn; url: #event-type-keydown; text: keydown;
    type: dfn; url: #event-type-keyup; text: keyup;
    type: dfn; url: #event-type-wheel; text: wheel;
    type: dfn; url: #event-type-beforeinput; text: beforeinput;
    type: dfn; url: #event-type-input; text: input;
    type: dfn; url: #event-type-compositionstart; text: compositionstart;
    type: dfn; url: #event-type-compositionupdate; text: compositionupdate;
    type: dfn; url: #event-type-compositionend; text: compositionend;
</pre>

Introduction {#sec-intro}
=====================

<div class="non-normative">

<em>This section is non-normative.</em>

When a user engages with a website, they expect their actions to cause changes to the website quickly.
In fact, <a href=https://www.nngroup.com/articles/response-times-3-important-limits/>research</a> suggests that any user input that is not handled within 100ms is considered slow.
Therefore, it is important to surface input events that could not achieve those guidelines.

A common way to monitor event latency consists of registering an event listener.
The timestamp at which the event was created can be obtained via the event's {{Event/timeStamp}}.
In addition, <a>performance.now()</a> could be called both at the beginning and at the end of the event handler logic.
By subtracting the hardware timestamp from the timestamp obtained at the beginning of the event handler,
the developer can compute the input delay: the time it takes for an input to start being processed.
By subtracting the timestamp obtained at the beginning of the event handler from the timestamp obtained at the end of the event handler,
the developer can compute the amount of synchronous work performed in the event handler.

This approach has several fundamental flaws.
First, requiring event listeners precludes measuring event latency very early in the page load because
listeners will likely not be registered yet at that point in time.
Second, developers that are only interested in the input delay might be forced to add new listeners to events that originally did not have one.
This adds unnecessary performance overhead to the event latency calculation.
And lastly, it would be very hard to measure asynchronous work caused by the event via this approach.

This specification provides an alternative to event latency monitoring that solves some of these problems.
Since the user agent computes the timestamps, there is no need for event listeners in order to measure performance.
This means that even events that occur very early in the page load can be captured.
This also enables visibility into slow events without requiring analytics providers to attempt to patch and subscribe to every conceivable event.
In addition to this, the website's performance will not suffer from the overhead of unneeded event listeners.
Finally, this specification allows developers to obtain detailed information about the timing of
the rendering that occurs right after the event has been processed.
This can be useful to measure the overhead of website modifications that are triggered by events.

The very first user interaction has a disproportionate impact on user experience, and is often disproportionately slow.
It's slow because it's often blocked on javascript execution that is not properly split into chunks during page load.
The latency of the website's response to the first user interaction can be considered a key responsiveness and loading metric.
To that effect, this API surfaces all the timing information about this interaction, even when this interaction is not handled slowly.
This allows developers to measure percentiles and improvements without having to register event handlers.

</div>

Events exposed {#sec-events-exposed}
------------------------

The Event Timing API exposes timing information for certain events.
Certain types of events are considered, and timing information is exposed when the time difference between user input and paint operations that follow input processing exceeds a certain threshold.

<div algorithm="considered for Event Timing">
    Given an <var>event</var>, to determine if it should be <dfn>considered for Event Timing</dfn>, run the following steps:
    * If <var>event</var>'s {{Event/isTrusted}} attribute value is set to <code>false</code>, return <code>false</code>.
    * Otherwise, return <code>true</code> if <var>event</var>'s {{Event/type}} is one of the following (return <code>false</code> otherwise):
    <!-- MouseEvents -->
        <a>auxclick</a>, <a>click</a>, <a>dblclick</a>, <a>mousedown</a>, <a>mouseenter</a>, <a>mouseleave</a>, <a>mousemove</a>, <a>mouseout</a>, <a>mouseover</a>, <a>mouseup</a>,
    <!-- PointerEvents -->
        <a>pointerover</a>, <a>pointerenter</a>, <a>pointerdown</a>, <a>pointermove</a>, <a>pointerup</a>, <a>pointercancel</a>, <a>pointerout</a>, <a>pointerleave</a>, <a>gotpointercapture</a>, <a>lostpointercapture</a>
    <!-- TouchEvents -->
        <a>touchStart</a>, <a>touchend</a>, <a>touchmove</a>, <a>touchcancel</a>,
    <!-- KeyboardEvents -->
        <a>keydown</a>, <a>keyup</a>,
    <!-- WheelEvents -->
        <a>wheel</a>,
    <!-- InputEvents -->
        <a>beforeinput</a>, <a>input</a>,
    <!-- CompositionEvents -->
        <a>compositionstart</a>, <a>compositionupdate</a>, <a>compositionend</a>.
</div>

The Event Timing API also exposes timing information about the first user interaction among the following:
* <a>keydown</a>
* <a>mousedown</a>
* <a>pointerdown</a> which is followed by <a>pointerup</a>
* <a>click</a>

Usage Example {#sec-example}
------------------------

<pre class="example highlight">
    const observer = new PerformanceObserver(function(list) {
        const perfEntries = list.getEntries().forEach(entry => {
            if (entry.processingStart !== 0) {
                const inputDelay = entry.processingStart - entry.startTime;
                // Report the input delay when the processing start was provided.
            }
            // Report full input duration via entry.duration.
        });
    });
    // Register observer for event.
    observer.observe({entryTypes: ["event"]});
    ...
    // Later on, we can also directly query the first input information.
    const firstArray = performance.getEntriesByType('firstInput');
    if (firstArray.length !== 0) {
        const firstInput = firstArray[0];
        // Process the first input event and report back...
    }
}
</pre>

The following are sample use cases that could be achieved by using this API:
* Clicking a button changes the sorting order on a table. Measure how long it takes from the click until we display reordered content.
* A user drags a slider to control volume. Measure the latency to drag the slider.
* Hovering a menu item triggers a flyout menu. Measure the latency for the flyout to appear.
* Measure the 75'th percentile of the latency of the first user click (whenever click happens to be the first user interaction).

Event Timing {#sec-event-timing}
=======================================

Event Timing adds the following interfaces:

{{PerformanceEventTiming}} interface {#sec-performance-event-timing}
------------------------------------------------------------------------

<pre class="idl">
[Exposed=Window]
interface PerformanceEventTiming : PerformanceEntry {
    readonly attribute DOMHighResTimeStamp processingStart;
    readonly attribute DOMHighResTimeStamp processingEnd;
    readonly attribute boolean cancelable;
};
</pre>

A user agent implementing the Event Timing API must perform the following steps:
1. Run the <a>register a performance entry type</a> algorithm  with <code>"firstInput"</code> as input.
1. Run the <a>register a performance entry type</a> algorithm  with <code>"event"</code> as input.

<div class="non-normative">

<em>
    This remainder of this section is non-normative.
    The values of the attributes of {{PerformanceEventTiming}} are set in the processing model in [[#sec-processing-model]].
    This section provides an informative summary of how they will be set.
</em>

Each {{PerformanceEventTiming}} object reports timing information about an <dfn for=PerformanceEventTiming>associated {{Event}}</dfn>.

{{PerformanceEventTiming}} extends the following attributes of the {{PerformanceEntry}} interface:

<dl>
    <dt>{{PerformanceEntry/name}}</dt>
    <dd>The {{PerformanceEntry/name}} attribute's getter provides the <a>associated event</a>'s {{Event/type}}.</dd>
    <dt>{{PerformanceEntry/entryType}}</dt>
    <dd>The {{PerformanceEntry/entryType}} attribute's getter returns <code>"event"</code> (for long events) or <code>"firstInput"</code> (for the first user interaction).</dd>
    <dt>{{PerformanceEntry/startTime}}</dt>
    <dd>The {{PerformanceEntry/startTime}} attribute's getter returns the <a>associated event</a>'s {{Event/timeStamp}}.</dd>
    <dt>{{PerformanceEntry/duration}}</dt>
    <dd>The {{PerformanceEntry/duration}} attribute's getter returns the difference between
    the time of the first <a>update the rendering</a> step occurring after <a>associated event</a> has been dispatched
    and the {{PerformanceEntry/startTime}}, rounded to the nearest 8 ms.</dd>
</dl>

{{PerformanceEventTiming}} has the following additional attributes:

<dl dfn-type=attribute dfn-for=PerformanceEventTiming link-for=PerformanceEventTiming>
    <dt>{{processingStart}}</dt>
    <dd>
        The <dfn>processingStart</dfn> attribute's getter returns the time when event handlers start to execute, or
        0 if the event dispatching logic is skipped (this can happen when there are no event handlers).
    </dd>
    <dt>{{processingEnd}}</dt>
    <dd>
        The <dfn>processingEnd</dfn> attribute's getter returns the time when event handlers have finished executing, or
        0 if the event dispatching logic is skipped (this can happen when there are no event handlers).
    </dd>
    <dt>{{cancelable}}</dt>
    <dd>
        The <dfn>cancelable</dfn> attribute's getter returns the <a>associated event</a>'s {{Event/cancelable}} attribute value.
    </dd>
</dl>

</div>

{{EventCounts}} interface {#sec-event-counts}
------------------------

<pre class="idl">
[Exposed=Window]
interface EventCounts {
    readonly maplike&lt;DOMString, unsigned long long&gt;;
};
</pre>

The {{EventCounts}} object is a map where the keys are event <a href=Event/type>types</a> and the values are the number of events that have been dispatched that are of that {{Event/type}}.
Only events whose {{Event/type}} is supported by {{PerformanceEventTiming}} entries (see section [[#sec-events-exposed]]) are counted via this map.

Extensions to the {{Performance}} interface {#sec-extensions}
------------------------

<pre class="idl">
[Exposed=Window]
partial interface Performance {
    [SameObject] readonly attribute EventCounts eventCounts;
};
</pre>

The {{Performance/eventCounts}} attribute's getter returns a map with entries of the form &lt;<var>type</var>, <var>num-events</var>&gt;.
This means that there have been <var>num-events</var> dispatched such that their {{Event/type}} attribute value is equal to <var>type</var>.

Processing model {#sec-processing-model}
========================================

Modifications to the DOM specification {#sec-modifications-DOM}
--------------------------------------------------------

<em>This section will be removed once the <a href=https://dom.spec.whatwg.org>DOM specification</a> has been modified.</em>

<div algorithm="additions to event dispatch">
    We modify the <a>event dispatch algorithm</a> as follows.

    Right after step 1, we add the following step:

    * Invoke the algorithm to <a>initialize event timing</a> passing <em>event</em> and the <a>current high resolution time</a> as inputs. Let <var>timingEntry</var> be the output.

    Right before the returning step of that algorithm, add the following step:

    * Invoke the algorithm to <a>finalize event timing</a> passing <var>timingEntry</var>, <em>target</em>, and the <a>current high resolution time</a> as inputs.
</div>

Modifications to the HTML specification {#sec-modifications-HTML}
--------------------------------------------------------

<em>This section will be removed once the <a href=https://html.spec.whatwg.org/multipage>HTML specification</a> has been modified.</em>

Each {{Window}} has <dfn>pendingEventEntries</dfn>, a list that stores {{PerformanceEventTiming}} objects, which will initially be empty.
Each {{Window}} also has <dfn>pendingPointerDown</dfn>, a pointer to a {{PerformanceEventTiming}} entry which is initially <code>null</code>.
Finally, each {{Window}} has <dfn>hasDispatchedEvent</dfn>, a boolean which is initially set to <code>false</code>.

<div algorithm="additions to update rendering">
    In the <a>update the rendering</a> step of the <a>event loop processing model</a>, add a step right after the step that calls <a>mark paint timing</a>:

    1. For each <a>fully active</a> {{Document}} in <em>docs</em>, invoke the algorithm to <a>dispatch pending Event Timing entries</a> for that {{Document}}.
</div>

Initialize event timing {#sec-init-event-timing}
--------------------------------------------------------

<div algorithm="initialize event timing">
    When asked to <dfn>initialize event timing</dfn>, with <var>event</var> and <var>processing start</var> as inputs, run the following steps:

    1. If the algorithm to determine if <var>event</var> should be <a>considered for Event Timing</a> returns <code>false</code>, then return <code>null</code>.
    1. Let <var>timingEntry</var> be a new {{PerformanceEventTiming}} object.
    1. Set <var>timingEntry</var>'s {{PerformanceEntry/name}} to <var>event</var>'s {{Event/type}} attribute value.
    1. Set <var>timingEntry</var>'s {{PerformanceEntry/entryType}} to <code>"event"</code>.
    1. Set <var>timingEntry</var>'s {{PerformanceEntry/startTime}} as follows:
        1. If <var>event</var>'s {{Event/type}} attribute value is equal to <code>"pointermove"</code>, set <var>timingEntry</var>'s {{PerformanceEntry/startTime}} to <code><var>event</var>.<a>getCoalescedEvents()</a>[0].{{PerformanceEntry/startTime}}</code>.
        1. Otherwise, set <var>timingEntry</var>'s {{PerformanceEntry/startTime}} to <code><var>event</var>.{{Event/timeStamp}}</code>.
    1. Set <var>timingEntry</var>'s {{processingStart}} to <var>processing start</var>.
    1. Set <var>timingEntry</var>'s {{cancelable}} to <var>event</var>'s {{Event/cancelable}} attribute value.
    1. Return <var>timingEntry</var>.
</div>

Finalize event timing {#sec-fin-event-timing}
--------------------------------------------------------

<div algorithm="finalize event timing">
    When asked to to <dfn>finalize event timing</dfn>, with <var>timingEntry</var>, <var>target</var>, and <var>processing end</var> as inputs, run the following steps:

    1. If <var>timingEntry</var> is <code>null</code>, abort these steps.
    1. Let <var>relevant global</var> be <var>target</var>'s <a>relevant global object</a>.
    1. If <var>relevant global</var> does not <a>implement</a> {{Window}}, abort these steps.
    1. Set <var>timingEntry</var>'s {{processingEnd}} to <var>processing end</var>.
    1. Append <var>timingEntry</var> to <var>relevant global</var>’s <a>pendingEventEntries</a>.
</div>

Dispatch pending Event Timing entries {#sec-dispatch-pending}
--------------------------------------------------------

<div algorithm="dispatch pending Event Timing entries">
    When asked to <dfn>dispatch pending Event Timing entries</dfn> for a {{Document}} <var>doc</var>, run the following steps:

    1. Let <var>window</var> be <var>doc</var>'s <a>relevant global object</a>.
    1. Let <var>rendering-timestamp</var> be the <a>current high resolution time</a>.
    1. For each <var>timingEntry</var> in <var>window</var>'s <a>pendingEventEntries</a>:
        1. Set <var>timingEntry</var>'s {{PerformanceEntry/duration}} by running the following steps:
            1. Let <var>difference</var> be <code><var>rendering-timestamp</var> - <var>timingEntry</var>.{{PerformanceEntry/startTime}}</code>.
            1. Set <var>timingEntry</var>'s {{PerformanceEntry/duration}} to <code><a>Math.round</a>(<var>difference</var>/8)*8</code>.
        1. Perform the following steps to update the event counts:
            1. If <code><var>window</var>.{{WindowOrWorkerGlobalScope/performance}}.{{Performance/eventCounts}}</code> does not contain a key <code><var>timingEntry</var>.{{PerformanceEntry/name}}</code>, then set <code><var>window</var>.{{WindowOrWorkerGlobalScope/performance}}.{{Performance/eventCounts}}[<var>timingEntry</var>.{{PerformanceEntry/name}}]</code> to 1.
            1. Otherwise, increase <code><var>window</var>.{{WindowOrWorkerGlobalScope/performance}}.{{Performance/eventCounts}}[<var>timingEntry</var>.{{PerformanceEntry/name}}]</code> by 1.
        1. If <var>timingEntry</var>'s {{PerformanceEntry/duration}} attribute value is greater than or equal to 104, then <a>queue the entry</a> <var>timingEntry</var>.
        1. If <var>window</var>'s <a>hasDispatchedEvent</a> is <code>false</code>, run the following steps:
            1. If <var>timingEntry</var>'s {{PerformanceEntry/name}} attribute value is <code>"pointerdown"</code>, run the following steps:
                1. Set <var>window</var>'s <a>pendingPointerDown</a> to a copy of <var>timingEntry</var>.
                1. Set the {{PerformanceEntry/entryType}} of <var>window</var>'s <a>pendingPointerDown</a> to <code>"firstInput"</code>.
            1. Otherwise, run the following steps:
                1. If <var>timingEntry</var>'s {{PerformanceEntry/name}} attribute value is <code>"pointerup"</code> AND if <var>window</var>'s <a>pendingPointerDown</a> is not <code>null</code>, then:
                    1. Set <var>window</var>'s <a>hasDispatchedEvent</a> to <code>true</code>.
                    1. <a href=https://w3c.github.io/performance-timeline/#dfn-queue-a-performanceentry>Queue</a> <var>window</var>'s <a>pendingPointerDown</a>.
                1. Otherwise, if <var>timingEntry</var>'s {{PerformanceEntry/name}} attribute value is one of <code>"click"</code>, <code>"keydown"</code> or <code>"mousedown"</code>, then:
                    1. Set <var>window</var>'s <a>hasDispatchedEvent</a> to <code>true</code>.
                    1. Let <var>newFirstInputDelayEntry</var> be a copy of <var>timingEntry</var>.
                    1. Set <var>newFirstInputDelayEntry</var>'s {{PerformanceEntry/entryType}} to <code>"firstInput"</code>.
                    1. <a>Queue the entry</a> <var>newFirstInputDelayEntry</var>.
</div>

Queueing other entries {#sec-queue-other}
--------------------------------------------------------

Some user agents skip some steps of the <a>event dispatch algorithm</a> for some events.
In fact, this is theoretically possible for any event which does not have associated event handlers or cause user agent defined behavior.
If the input is the first input, then the user agent MUST always queue the corresponding <code>"firstInput"</code> entry and it MUST do so via the <a>event dispatch algorithm</a>.
Otherwise, the user agent MAY opt not to queue the entry when there are no event handlers associated to the event.
This provides user agents with the flexibility to ignore input which never blocks on the main thread and for which <a>event dispatch algorithm</a> is skipped.

<div algorithm="report outside of event dispatch">
    To <em>create an event timing entry</em> outside of the <a>event dispatch algorithm</a>, the user agent must run the following steps:

    1. Let <var>event</var> be the event being measured and let <var>window</var> be the <a>relevant global object</a> of the target.
    1. Assert: <var>window</var> <a>implements</a> {{Window}}.
    1. Run the <a>initialize event timing</a> algorithm, passing in <var>event</var> and <code>0</code> as inputs.
    1. Let <var>timingEntry</var> be the output from the algorithm.
    1. Run the <a>finalize event timing</a> algorithm, passing in <var>timingEntry</var>, <var>window</var>, and <code>0</code> as inputs.
</div>

Note: processing the first input entry via the <a>event dispatch algorithm</a> ensures that the first input's {{PerformanceEntry/duration}} is calculated accurately.
If skipping first inputs without event handlers was allowed, or if they were processed outside of <a>event dispatch algorithm</a>, then statistical biases could be introduced.
For example, consider a website which initially only has a few event handlers.
This website would only receive first input entries for events targetting those event handlers, so the first input's {{PerformanceEntry/duration}} would be large on average.
If the website then added a trivial event handler for the page, the average first input {{PerformanceEntry/duration}} would decrease because it would now receive many first inputs from events that do not trigger the non-trivial event handlers.
But, in practice, the website having the trivial event handler will handle input more slowly.

Security & privacy considerations {#priv-sec}
===============================================

We would not like to introduce more high resolution timers to the web platform due to the security concerns entailed by such timers.
Event handler timestamps have the same accuracy as <a>performance.now()</a>.
Since {{processingStart}} and {{processingEnd}} could be computed without using this API,
exposing these attributes does not produce new attack surfaces.
Thus, {{PerformanceEntry/duration}} is the only one which requires further consideration.

The {{PerformanceEntry/duration}} has an 8 millisecond granularity (it is computed as such by performing rounding).
Thus, a high resolution timer cannot be produced from this timestamps.
However, it does introduce new information that is not readily available to web developers: the time pixels draw after an event has been processed.
We do not find security or privacy concerns on exposing the timestamp, especially given its granularity.
In an effort to expose the minimal amount of new information that is useful, we decided to pick 8 milliseconds as the granularity.
This allows relatively precise timing even for 120Hz displays.

The choice of 104 ms as the cutoff value for the {{PerformanceEntry/duration}} is just the first multiple of 8 greater than 100 ms.
An event whose rounded duration is greater than or equal to 104 ms will have its pre-rounded duration greater than or equal to 100 ms.
Such events are not handled in accordance with the RAIL performance model, which suggests applications respond within 100 ms to user input.
